import * as fs from 'fs';
import * as path from 'path';
import type { AgentId } from './types.js';
import { getShimsDir, getVersionsDir, ensureAgentsDir } from './state.js';
export { getShimsDir };
import { AGENTS } from './agents.js';

/**
 * Generate the shim script content for an agent.
 *
 * The shim resolves the version (project manifest -> global default) and execs
 * the appropriate binary. Config isolation is handled via symlinks:
 * ~/.{agent} -> ~/.agents/versions/{agent}/{version}/home/.{agent}/
 *
 * The symlink is updated by `agents use` when switching versions.
 */
function generateShimScript(agent: AgentId): string {
  const agentConfig = AGENTS[agent];
  const cliCommand = agentConfig.cliCommand;

  return `#!/bin/bash
# Auto-generated by agents-cli - do not edit
# Shim for ${agentConfig.name}

AGENTS_DIR="$HOME/.agents"
AGENT="${agent}"
CLI_COMMAND="${cliCommand}"

# Resolve version from project manifest or global default
resolve_version() {
  local dir="$PWD"

  # Walk up directory tree looking for .agents/agents.yaml
  while [ "$dir" != "/" ]; do
    local manifest="$dir/.agents/agents.yaml"
    if [ -f "$manifest" ]; then
      local version
      version=$(awk -v agent="$AGENT" '
        /^agents:/ { in_agents=1; next }
        in_agents && /^[^ ]/ { in_agents=0 }
        in_agents && $0 ~ "^  " agent ":" { gsub(/.*:[[:space:]]*["'"'"']?|["'"'"']?[[:space:]]*$/, ""); print; exit }
      ' "$manifest")

      if [ -n "$version" ]; then
        echo "$version"
        return
      fi
    fi
    dir=$(dirname "$dir")
  done

  # Fall back to global default from ~/.agents/agents.yaml
  local global_config="$AGENTS_DIR/agents.yaml"
  if [ -f "$global_config" ]; then
    awk -v agent="$AGENT" '
      /^agents:/ { in_agents=1; next }
      in_agents && /^[^ ]/ { in_agents=0 }
      in_agents && $0 ~ "^  " agent ":" { gsub(/.*:[[:space:]]*["'"'"']?|["'"'"']?[[:space:]]*$/, ""); print; exit }
    ' "$global_config"
  fi
}

VERSION=$(resolve_version)

if [ -z "$VERSION" ]; then
  echo "agents: no version of $AGENT configured" >&2
  echo "Run: agents add $AGENT@<version>" >&2
  exit 1
fi

VERSION_DIR="$AGENTS_DIR/versions/$AGENT/$VERSION"
BINARY="$VERSION_DIR/node_modules/.bin/$CLI_COMMAND"

if [ ! -x "$BINARY" ]; then
  echo "agents: $AGENT@$VERSION not installed" >&2
  echo "Run: agents add $AGENT@$VERSION" >&2
  exit 1
fi

exec "$BINARY" "$@"
`;
}

/**
 * Create a shim for an agent.
 */
export function createShim(agent: AgentId): string {
  ensureAgentsDir();
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);

  const script = generateShimScript(agent);
  fs.writeFileSync(shimPath, script, { mode: 0o755 });

  return shimPath;
}

/**
 * Remove the shim for an agent.
 */
export function removeShim(agent: AgentId): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);

  if (fs.existsSync(shimPath)) {
    fs.unlinkSync(shimPath);
    return true;
  }

  return false;
}

/**
 * Generate a versioned alias script that directly execs a specific version.
 * e.g., claude@2.0.65 -> directly runs that version's binary
 */
function generateVersionedAliasScript(agent: AgentId, version: string): string {
  const agentConfig = AGENTS[agent];

  return `#!/bin/bash
# Auto-generated by agents-cli - do not edit
# Direct alias for ${agentConfig.name}@${version}

BINARY="$HOME/.agents/versions/${agent}/${version}/node_modules/.bin/${agentConfig.cliCommand}"

if [ ! -x "$BINARY" ]; then
  echo "agents: ${agent}@${version} not installed" >&2
  exit 1
fi

exec "$BINARY" "$@"
`;
}

/**
 * Create a versioned alias for a specific agent version.
 * e.g., claude@2.0.65
 */
export function createVersionedAlias(agent: AgentId, version: string): string {
  ensureAgentsDir();
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const aliasPath = path.join(shimsDir, `${agentConfig.cliCommand}@${version}`);

  const script = generateVersionedAliasScript(agent, version);
  fs.writeFileSync(aliasPath, script, { mode: 0o755 });

  return aliasPath;
}

/**
 * Remove a versioned alias for a specific agent version.
 */
export function removeVersionedAlias(agent: AgentId, version: string): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const aliasPath = path.join(shimsDir, `${agentConfig.cliCommand}@${version}`);

  if (fs.existsSync(aliasPath)) {
    fs.unlinkSync(aliasPath);
    return true;
  }

  return false;
}

/**
 * Check if a versioned alias exists.
 */
export function versionedAliasExists(agent: AgentId, version: string): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const aliasPath = path.join(shimsDir, `${agentConfig.cliCommand}@${version}`);
  return fs.existsSync(aliasPath);
}

/**
 * Get the path to the agent's config directory in HOME.
 * e.g., ~/.claude for claude, ~/.codex for codex
 */
function getAgentConfigPath(agent: AgentId): string {
  const agentConfig = AGENTS[agent];
  const home = process.env.AGENTS_REAL_HOME || require('os').homedir();
  return agentConfig.configDir.replace(require('os').homedir(), home);
}

/**
 * Get the path to the version's config directory.
 * e.g., ~/.agents/versions/claude/2.0.65/home/.claude/
 */
function getVersionConfigPath(agent: AgentId, version: string): string {
  const agentConfig = AGENTS[agent];
  const versionsDir = getVersionsDir();
  const configDirName = `.${agent}`; // .claude, .codex, etc.
  return path.join(versionsDir, agent, version, 'home', configDirName);
}

/**
 * Switch the agent's config symlink to point to a specific version.
 * e.g., ~/.claude -> ~/.agents/versions/claude/2.0.65/home/.claude/
 *
 * Returns: { success: boolean, migrated?: boolean, error?: string }
 */
export function switchConfigSymlink(
  agent: AgentId,
  version: string
): { success: boolean; migrated?: boolean; error?: string } {
  const configPath = getAgentConfigPath(agent);
  const versionConfigPath = getVersionConfigPath(agent, version);

  // Ensure version config directory exists
  if (!fs.existsSync(versionConfigPath)) {
    fs.mkdirSync(versionConfigPath, { recursive: true });
  }

  try {
    const stat = fs.lstatSync(configPath);

    if (stat.isSymbolicLink()) {
      // Already a symlink - update it
      fs.unlinkSync(configPath);
      fs.symlinkSync(versionConfigPath, configPath);
      return { success: true };
    } else if (stat.isDirectory()) {
      // Real directory exists - migrate it to this version's config
      // Move contents to version config, then create symlink
      const tempPath = `${configPath}.backup.${Date.now()}`;
      fs.renameSync(configPath, tempPath);

      // Copy contents from backup to version config
      copyDirContents(tempPath, versionConfigPath);

      // Create symlink
      fs.symlinkSync(versionConfigPath, configPath);

      // Remove backup
      fs.rmSync(tempPath, { recursive: true, force: true });

      return { success: true, migrated: true };
    } else {
      return { success: false, error: `${configPath} exists but is not a directory or symlink` };
    }
  } catch (err: unknown) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      // Config path doesn't exist - create symlink
      fs.symlinkSync(versionConfigPath, configPath);
      return { success: true };
    }
    return { success: false, error: (err as Error).message };
  }
}

/**
 * Get the current config symlink target version, if any.
 */
export function getConfigSymlinkVersion(agent: AgentId): string | null {
  const configPath = getAgentConfigPath(agent);

  try {
    const stat = fs.lstatSync(configPath);
    if (!stat.isSymbolicLink()) {
      return null;
    }

    const target = fs.readlinkSync(configPath);
    // Extract version from path like ~/.agents/versions/claude/2.0.65/home/.claude
    const match = target.match(/versions\/[^/]+\/([^/]+)\/home/);
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

/**
 * Copy directory contents (non-recursive for top level, recursive for subdirs).
 */
function copyDirContents(src: string, dest: string): void {
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }

  const entries = fs.readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirContents(srcPath, destPath);
    } else if (entry.isSymbolicLink()) {
      const linkTarget = fs.readlinkSync(srcPath);
      if (!fs.existsSync(destPath)) {
        fs.symlinkSync(linkTarget, destPath);
      }
    } else {
      if (!fs.existsSync(destPath)) {
        fs.copyFileSync(srcPath, destPath);
      }
    }
  }
}

/**
 * Check if shim exists for an agent.
 */
export function shimExists(agent: AgentId): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);
  return fs.existsSync(shimPath);
}

/**
 * Get the path to the shim for an agent.
 */
export function getShimPath(agent: AgentId): string {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  return path.join(shimsDir, agentConfig.cliCommand);
}

/**
 * Check if shims directory is in PATH.
 */
export function isShimsInPath(): boolean {
  const shimsDir = getShimsDir();
  const pathDirs = (process.env.PATH || '').split(path.delimiter);
  return pathDirs.some((dir) => path.resolve(dir) === path.resolve(shimsDir));
}

/**
 * Get shell configuration instructions for adding shims to PATH.
 */
export function getPathSetupInstructions(): string {
  const shimsDir = getShimsDir();
  const shell = process.env.SHELL || '/bin/bash';
  const shellName = path.basename(shell);

  let rcFile: string;
  switch (shellName) {
    case 'zsh':
      rcFile = '~/.zshrc';
      break;
    case 'fish':
      return `Add to ~/.config/fish/config.fish:
  fish_add_path ${shimsDir}`;
    case 'bash':
    default:
      rcFile = '~/.bashrc';
      break;
  }

  return `Add to ${rcFile} (BEFORE any nvm/node setup):
  export PATH="${shimsDir}:$PATH"

IMPORTANT: Shims must come FIRST in PATH to override global installs.

Then restart your shell or run:
  source ${rcFile}`;
}

/**
 * Create shims for all installed agents.
 */
export function ensureAllShims(): void {
  const versionsDir = getVersionsDir();
  if (!fs.existsSync(versionsDir)) {
    return;
  }

  const entries = fs.readdirSync(versionsDir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory() && AGENTS[entry.name as AgentId]) {
      const agent = entry.name as AgentId;
      const agentVersionsDir = path.join(versionsDir, agent);
      const versions = fs.readdirSync(agentVersionsDir, { withFileTypes: true })
        .filter((e) => e.isDirectory());

      if (versions.length > 0 && !shimExists(agent)) {
        createShim(agent);
      }
    }
  }
}
