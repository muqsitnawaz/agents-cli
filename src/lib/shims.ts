import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import type { AgentId } from './types.js';
import { getShimsDir, getVersionsDir, ensureAgentsDir } from './state.js';
export { getShimsDir };
import { AGENTS } from './agents.js';

/**
 * Generate the shim script content for an agent.
 */
function generateShimScript(agent: AgentId): string {
  const agentConfig = AGENTS[agent];
  const cliCommand = agentConfig.cliCommand;

  return `#!/bin/bash
# Auto-generated by agents-cli - do not edit
# Shim for ${agentConfig.name}

AGENTS_DIR="$HOME/.agents"
AGENT="${agent}"
CLI_COMMAND="${cliCommand}"

# Resolve version from project manifest or global default
resolve_version() {
  local dir="$PWD"

  # Walk up directory tree looking for .agents/agents.yaml
  while [ "$dir" != "/" ]; do
    local manifest="$dir/.agents/agents.yaml"
    if [ -f "$manifest" ]; then
      # Extract version for this agent from YAML (flat format: agents: claude: "1.5.0")
      local version
      version=$(awk -v agent="$AGENT" '
        /^agents:/ { in_agents=1; next }
        in_agents && /^[^ ]/ { in_agents=0 }
        in_agents && $0 ~ "^  " agent ":" { gsub(/.*:[[:space:]]*["'"'"']?|["'"'"']?[[:space:]]*$/, ""); print; exit }
      ' "$manifest")

      if [ -n "$version" ]; then
        echo "$version"
        return
      fi
    fi
    dir=$(dirname "$dir")
  done

  # Fall back to global default from ~/.agents/agents.yaml
  local global_config="$AGENTS_DIR/agents.yaml"
  if [ -f "$global_config" ]; then
    awk -v agent="$AGENT" '
      /^agents:/ { in_agents=1; next }
      in_agents && /^[^ ]/ { in_agents=0 }
      in_agents && $0 ~ "^  " agent ":" { gsub(/.*:[[:space:]]*["'"'"']?|["'"'"']?[[:space:]]*$/, ""); print; exit }
    ' "$global_config"
  fi
}

VERSION=$(resolve_version)

if [ -z "$VERSION" ]; then
  echo "agents: no version of $AGENT configured" >&2
  echo "Run: agents add $AGENT@<version>" >&2
  exit 1
fi

VERSION_DIR="$AGENTS_DIR/versions/$AGENT/$VERSION"
BINARY="$VERSION_DIR/node_modules/.bin/$CLI_COMMAND"

if [ ! -x "$BINARY" ]; then
  echo "agents: $AGENT@$VERSION not installed" >&2
  echo "Run: agents add $AGENT@$VERSION" >&2
  exit 1
fi

# Isolate agent config per version, pass through everything else
REAL_HOME="$HOME"
VERSION_HOME="$VERSION_DIR/home"
mkdir -p "$VERSION_HOME"

# Only these dirs get isolated per version - everything else is symlinked through
ISOLATED=".claude .codex .gemini .cursor .opencode .agents"

# Migration: clean up old Library directory (replaced by symlink)
if [ -e "$VERSION_HOME/Library" ] && [ ! -L "$VERSION_HOME/Library" ]; then
  rm -rf "$VERSION_HOME/Library"
fi

# Symlink all HOME entries except isolated agent config dirs
for entry in "$REAL_HOME"/.[!.]* "$REAL_HOME"/*; do
  [ -e "$entry" ] || [ -L "$entry" ] || continue
  name="$(basename "$entry")"
  case " $ISOLATED " in *" $name "*) continue ;; esac
  target="$VERSION_HOME/$name"
  [ -e "$target" ] || [ -L "$target" ] || ln -s "$entry" "$target" 2>/dev/null
done

# Check if this agent should sync central resources
is_synced() {
  local global_config="$AGENTS_DIR/agents.yaml"
  if [ -f "$global_config" ]; then
    awk -v agent="$AGENT" '
      /^sync:/ { in_sync=1; next }
      in_sync && /^[^ ]/ { exit }
      in_sync && /^  - / { gsub(/^  - /, ""); if ($0 == agent) { print "yes"; exit } }
    ' "$global_config"
  fi
}

# Agent-specific config directory and subdirectory mappings
AGENT_CONFIG_DIR=".${agent}"
AGENT_COMMANDS_SUBDIR="${agentConfig.commandsSubdir}"

# If agent is in sync list, symlink central resources
if [ "$(is_synced)" = "yes" ]; then
  AGENT_DIR="$VERSION_HOME/$AGENT_CONFIG_DIR"
  mkdir -p "$AGENT_DIR"

  # Symlink commands (agent uses different subdir names)
  if [ -d "$AGENTS_DIR/commands" ] && [ ! -e "$AGENT_DIR/$AGENT_COMMANDS_SUBDIR" ]; then
    ln -s "$AGENTS_DIR/commands" "$AGENT_DIR/$AGENT_COMMANDS_SUBDIR" 2>/dev/null
  fi

  # Symlink hooks (if agent supports them)
  if [ -d "$AGENTS_DIR/hooks" ] && [ ! -e "$AGENT_DIR/hooks" ] && [ "${agentConfig.supportsHooks}" = "true" ]; then
    ln -s "$AGENTS_DIR/hooks" "$AGENT_DIR/hooks" 2>/dev/null
  fi

  # Symlink skills
  if [ -d "$AGENTS_DIR/skills" ] && [ ! -e "$AGENT_DIR/skills" ]; then
    ln -s "$AGENTS_DIR/skills" "$AGENT_DIR/skills" 2>/dev/null
  fi

  # Link canonical AGENTS.md as this agent's instructionsFile name
  AGENT_INSTRUCTIONS_FILE="${agentConfig.instructionsFile}"
  CANONICAL_MEMORY="$AGENTS_DIR/memory/AGENTS.md"
  if [ -f "$CANONICAL_MEMORY" ] && [ ! -e "$AGENT_DIR/$AGENT_INSTRUCTIONS_FILE" ]; then
    ln -s "$CANONICAL_MEMORY" "$AGENT_DIR/$AGENT_INSTRUCTIONS_FILE" 2>/dev/null
  fi

  # Symlink other memory files (e.g. SOUL.md) by original name
  if [ -d "$AGENTS_DIR/memory" ]; then
    for memfile in "$AGENTS_DIR/memory"/*; do
      [ -f "$memfile" ] || continue
      memname="$(basename "$memfile")"
      [ "$memname" = "AGENTS.md" ] && continue
      [ -e "$AGENT_DIR/$memname" ] || ln -s "$memfile" "$AGENT_DIR/$memname" 2>/dev/null
    done
  fi
fi

# Symlink entries from real agent config dir into version home
# Ensures user-installed skills, settings, hooks, etc. are visible
# Sync-provided resources (above) take precedence
REAL_AGENT_DIR="$REAL_HOME/$AGENT_CONFIG_DIR"
AGENT_DIR="$VERSION_HOME/$AGENT_CONFIG_DIR"
mkdir -p "$AGENT_DIR"

if [ -d "$REAL_AGENT_DIR" ]; then
  for entry in "$REAL_AGENT_DIR"/* "$REAL_AGENT_DIR"/.[!.]*; do
    [ -e "$entry" ] || [ -L "$entry" ] || continue
    name="$(basename "$entry")"
    target="$AGENT_DIR/$name"
    [ -e "$target" ] || [ -L "$target" ] || ln -s "$entry" "$target" 2>/dev/null
  done
fi

export AGENTS_REAL_HOME="$REAL_HOME"
export HOME="$VERSION_HOME"

exec "$BINARY" "$@"
`;
}

/**
 * Create a shim for an agent.
 */
export function createShim(agent: AgentId): string {
  ensureAgentsDir();
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);

  const script = generateShimScript(agent);
  fs.writeFileSync(shimPath, script, { mode: 0o755 });

  return shimPath;
}

/**
 * Remove the shim for an agent.
 */
export function removeShim(agent: AgentId): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);

  if (fs.existsSync(shimPath)) {
    fs.unlinkSync(shimPath);
    return true;
  }

  return false;
}

/**
 * Check if shim exists for an agent.
 */
export function shimExists(agent: AgentId): boolean {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  const shimPath = path.join(shimsDir, agentConfig.cliCommand);
  return fs.existsSync(shimPath);
}

/**
 * Get the path to the shim for an agent.
 */
export function getShimPath(agent: AgentId): string {
  const shimsDir = getShimsDir();
  const agentConfig = AGENTS[agent];
  return path.join(shimsDir, agentConfig.cliCommand);
}

/**
 * Check if shims directory is in PATH.
 */
export function isShimsInPath(): boolean {
  const shimsDir = getShimsDir();
  const pathDirs = (process.env.PATH || '').split(path.delimiter);
  return pathDirs.some((dir) => path.resolve(dir) === path.resolve(shimsDir));
}

/**
 * Get shell configuration instructions for adding shims to PATH.
 */
export function getPathSetupInstructions(): string {
  const shimsDir = getShimsDir();
  const shell = process.env.SHELL || '/bin/bash';
  const shellName = path.basename(shell);

  let rcFile: string;
  switch (shellName) {
    case 'zsh':
      rcFile = '~/.zshrc';
      break;
    case 'fish':
      return `Add to ~/.config/fish/config.fish:
  fish_add_path ${shimsDir}`;
    case 'bash':
    default:
      rcFile = '~/.bashrc';
      break;
  }

  return `Add to ${rcFile} (BEFORE any nvm/node setup):
  export PATH="${shimsDir}:$PATH"

IMPORTANT: Shims must come FIRST in PATH to override global installs.

Then restart your shell or run:
  source ${rcFile}`;
}

/**
 * Create shims for all installed agents.
 */
export function ensureAllShims(): void {
  const versionsDir = getVersionsDir();
  if (!fs.existsSync(versionsDir)) {
    return;
  }

  const entries = fs.readdirSync(versionsDir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory() && AGENTS[entry.name as AgentId]) {
      const agent = entry.name as AgentId;
      const agentVersionsDir = path.join(versionsDir, agent);
      const versions = fs.readdirSync(agentVersionsDir, { withFileTypes: true })
        .filter((e) => e.isDirectory());

      if (versions.length > 0 && !shimExists(agent)) {
        createShim(agent);
      }
    }
  }
}
